<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zotero Exports Screening Tool</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: auto; }
    .record { margin-bottom: 20px; }
    button { margin-right: 10px; padding: 10px 20px; }
    #status { margin: 20px 0; font-weight: bold; }
    #encouragement { margin: 10px 0; font-size: 1.2em; color: green; }
    #emojiFace { font-size: 3em; float: left }
    .clear { clear: both }
    #mainTitle { font-size: 30px; float: left }
  </style>
</head>
<body>
  <div id="topBanner">
    <div id="mainTitle">Zotero Exports Screening Tool</div>
    <div id="emojiFace">üòê</div>
    <div id="encouragement"></div>
  </div>
  <br class="clear" />
  <h6>Import Data CSV</h6>
  <input type="file" id="csvFile" accept=".csv" />
  <div id="status"></div>
  <button onclick="saveDecision('yes')">Yes</button>
  <button onclick="saveDecision('maybe')">Maybe</button>
  <button onclick="saveDecision('no')">No</button>
  <div class="record" id="recordContainer"></div>
  <button onclick="exportProgress()">Export Progress</button>
  <h6>Import Progress Data File</h6>
  <input type="file" id="jsonImport" accept=".json" />

  <script>
    let records = [];
    let currentIndex = 0;
    let decisions = {};
    let db;

    const openRequest = indexedDB.open("ScreeningDB", 1);
    openRequest.onupgradeneeded = function(event) {
      db = event.target.result;
      if (!db.objectStoreNames.contains("decisions")) {
        db.createObjectStore("decisions");
      }
    };

    openRequest.onsuccess = function(event) {
      db = event.target.result;
      loadDecisions().then(() => showRecord());
    };

    openRequest.onerror = function() {
      console.error("IndexedDB error");
    };

    function loadDecisions() {
      return new Promise((resolve) => {
        const tx = db.transaction("decisions", "readonly");
        const store = tx.objectStore("decisions");
        const request = store.getAllKeys();

        request.onsuccess = function() {
          const keys = request.result;
          const tx2 = db.transaction("decisions", "readonly");
          const store2 = tx2.objectStore("decisions");

          currentIndex = Object.keys(decisions).length;

          let loaded = 0;
          keys.forEach(key => {
            const req = store2.get(key);
            req.onsuccess = function() {
              decisions[key] = req.result;
              loaded++;
              if (loaded === keys.length) {
                resolve();
              }
            };
          });

          if (keys.length === 0) resolve();
        };
      });
    }

    function saveDecisionToDB(index, value) {
      const tx = db.transaction("decisions", "readwrite");
      const store = tx.objectStore("decisions");
      store.put(value, index);
    }

    document.getElementById('csvFile').addEventListener('change', (event) => {
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target.result;
        records = parseCSV(text);
        showRecord();
      };
      currentIndex = Object.keys(decisions).length;

      reader.readAsText(file);
    });

    document.getElementById('jsonImport').addEventListener('change', (event) => {
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.onload = (e) => {
        const imported = JSON.parse(e.target.result);
        const tx = db.transaction("decisions", "readwrite");
        const store = tx.objectStore("decisions");
        for (const [key, val] of Object.entries(imported)) {
          store.put(val, key);
          decisions[key] = val;
        }
        showRecord();
      };
      reader.readAsText(file);
    });

    function parseCSV(data) {
      const lines = data.split(/\r?\n/);
      const result = [];
      const headers = parseCSVLine(lines[0]);
      for (let i = 1; i < lines.length; i++) {
        if (!lines[i].trim()) continue;
        const values = parseCSVLine(lines[i]);
        const obj = {};
        headers.forEach((h, j) => obj[h] = values[j] || '');
        result.push(obj);
      }
      return result;
    }

    function parseCSVLine(line) {
      const regex = /"([^"]*(?:""[^"]*)*)"|([^,]+)/g;
      const result = [];
      let match;
      while ((match = regex.exec(line)) !== null) {
        if (match[1] !== undefined) {
          result.push(match[1].replace(/""/g, '"'));
        } else if (match[2] !== undefined) {
          result.push(match[2]);
        } else {
          result.push('');
        }
      }
      return result;
    }

    function showRecord() {
      while (currentIndex < records.length && decisions[currentIndex]) {
        currentIndex++;
      }
      updateStatus();

      const record = records[currentIndex];
      if (!record) {
        document.getElementById('recordContainer').innerHTML = '<p>No records.</p>';
        return;
      }
      document.getElementById('recordContainer').innerHTML = `
        <p><strong>Author:</strong> ${record['Author'] || ''}</p>
        <p><strong>Publication Year:</strong> ${record['Publication Year'] || ''}</p>
        <p><strong>Publication Title:</strong> ${record['Publication Title'] || ''}</p>
        <p><strong>Title:</strong> ${record['Title'] || ''}</p>
        <p><strong>Abstract Note:</strong> ${record['Abstract Note'] || ''}</p>
      `;
    }

    function saveDecision(decision) {
      if (!records[currentIndex]) return;
      decisions[currentIndex] = decision;
      const key = records[currentIndex]['Key'];
      saveDecisionToDB(key, decision);
      currentIndex++;
      showEncouragement();
      showRecord();
    }

    function showEncouragement() {
      const reviewed = Object.keys(decisions).length;
      const howManyBetweenEncouragements = 10;
      const messageIndex = Math.floor(reviewed / howManyBetweenEncouragements);
      const goodJobMessages = [
        // Genuine & Encouraging
        "Great job‚Äîyour hard work really shows!",
        "You nailed it!",
        "Outstanding performance‚Äîkeep it up!",
        "That was a job well done.",
        "You‚Äôve outdone yourself this time.",
        "Your effort made all the difference.",
        "Bravo! You handled that like a pro.",
        "That was impressive‚Äîseriously!",
        "You crushed it.",
        "I knew you could do it!",

        // Warm & Supportive
        "You‚Äôre really shining today!",
        "Gold star for you! ‚≠ê",
        "That was smooth and solid‚Äîwell done!",
        "You‚Äôre making this look easy.",
        "You're on a roll!",
        "That deserves a round of applause üëè",
        "I‚Äôm proud of the way you handled that.",
        "Excellence suits you.",
        "That was a 10/10 moment!",
        "Keep climbing‚Äîyou‚Äôre doing great.",

        // Fun & Playful
        "That was so good I thought it was CGI.",
        "Did you eat excellence for breakfast?",
        "You crushed that like a soda can.",
        "That was fire‚Äîüî•üî•üî•",
        "You‚Äôre basically a wizard at this point.",
        "Look at you, being all awesome and stuff.",
        "That was smoother than jazz on Sunday morning.",
        "Someone call the award committee!",
        "Can I get your autograph after that performance?",
        "You just raised the bar... again.",

        // Quick Praise
        "Nice one!",
        "Love that energy.",
        "Way to go!",
        "Keep that momentum!",
        "Boom‚Äîjust like that!",
        "That‚Äôs what I‚Äôm talking about.",
        "Clean, clear, and clever‚Äînice!",
        "You make it look easy.",
        "Smooth move!",
        "Every step you're taking is solid gold.",

        // Extra-Encouraging
        "That was legendary.",
        "Seriously, how do you keep leveling up like this?",
        "You‚Äôre absolutely crushing your goals!",
        "If success had a face, it‚Äôd be yours.",
        "Your dedication is next-level.",
        "Just when I think you‚Äôve peaked, you prove me wrong.",
        "You turned challenge into triumph.",
        "That was nothing short of excellence.",
        "You're basically a one-person success team.",
        "Let‚Äôs call it what it is: amazing."
      ];

      let msg = goodJobMessages[messageIndex];

      const emojiEl = document.getElementById('emojiFace');
      if (reviewed < 25) emojiEl.textContent = "‚òπÔ∏è";
      else if (reviewed < 50) emojiEl.textContent = "üòê";
      else if (reviewed < 75) emojiEl.textContent = "üôÇ";
      else emojiEl.textContent = "üòÑ";

      document.getElementById('encouragement').textContent = msg;
    }

    function updateStatus() {
      const reviewed = Object.keys(decisions).length;
      const pending = records.length - reviewed;
      const percentage = Math.round((reviewed / records.length) * 100, 2);
      document.getElementById('status').textContent = `Reviewed: ${reviewed} / ${records.length} (${percentage}%) | Pending: ${pending}`;
    }

    function exportProgress() {
      const tx = db.transaction("decisions", "readonly");
      const store = tx.objectStore("decisions");
      const request = store.getAllKeys();
      const allData = {};

      request.onsuccess = function() {
        const keys = request.result;
        const tx2 = db.transaction("decisions", "readonly");
        const store2 = tx2.objectStore("decisions");
        let count = 0;

        keys.forEach((key) => {
          const req = store2.get(key);
          req.onsuccess = function() {
            allData[key] = req.result;
            count++;
            if (count === keys.length) {
              const blob = new Blob([JSON.stringify(allData)], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'progress.json';
              a.click();
              URL.revokeObjectURL(url);
            }
          };
        });
      };
    }
  </script>
</body>
</html>
